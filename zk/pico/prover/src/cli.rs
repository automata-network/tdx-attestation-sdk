use clap::{Args, Parser, Subcommand};
use std::fs::read_to_string;
use std::path::PathBuf;

const MANIFEST_DIR: &str = env!("CARGO_MANIFEST_DIR");
const DEFAULT_QUOTE_PATH: &str = "./data/quote.hex";

#[derive(Parser)]
#[command(name = "DcapPicoApp")]
#[command(version = "1.0.0")]
#[command(about = "Gets Pico Proof for DCAP Quote Verification")]
pub struct Cli {
    #[command(subcommand)]
    pub command: Commands,
}

#[derive(Subcommand)]
pub enum Commands {
    /// Fetches proof from Pico and verifies DCAP quote
    Prove(DcapArgs),

    /// De-serializes and prints information about the Output
    Deserialize(OutputArgs),

    /// input.bin parser
    Parse(InputArgs),

    /// generate EVM input
    GenerateEvmInputs,
}

#[derive(Args)]
pub struct DcapArgs {
    /// The input quote provided as a hex string, this overwrites the --quote-path argument
    #[arg(short = 'q', long = "quote-hex")]
    pub quote_hex: Option<String>,

    /// Optional: The path to a quote.hex file. Default: /data/quote.hex or overwritten by the --quote-hex argument if provided.
    #[arg(short = 'p', long = "quote-path", env = "QUOTE_HEX_PATH")]
    pub quote_path: Option<PathBuf>,

    /// Optional: The Guest zkVM input generated by running input.rs executable
    #[arg(short = 'i', long = "input")]
    pub guest_input_path: Option<PathBuf>,
}

#[derive(Args)]
pub struct OutputArgs {
    #[arg(short = 'o', long = "output")]
    pub output: String,
}

#[derive(Args)]
pub struct InputArgs {
    #[arg(short = 'i', long = "input-path", default_value = "input.bin")]
    pub input: PathBuf,

    #[arg(short = 'o', long = "output-dir")]
    pub output_dir: Option<PathBuf>,
}

pub fn get_quote(path: &Option<PathBuf>, hex: &Option<String>) -> Vec<u8> {
    let error_msg: &str = "Failed to read quote from the provided path";
    match hex {
        Some(h) => {
            let quote_hex = hex::decode(h).expect(error_msg);
            quote_hex
        }
        _ => match path {
            Some(p) => {
                let quote_string = read_to_string(p).expect(error_msg);
                let processed = remove_prefix_if_found(&quote_string);
                let quote_hex = hex::decode(processed).expect(error_msg);
                quote_hex
            }
            _ => {
                let default_path =
                    PathBuf::from(format!("{}/{}", MANIFEST_DIR, DEFAULT_QUOTE_PATH));
                let quote_string = read_to_string(default_path).expect(error_msg);
                let processed = remove_prefix_if_found(&quote_string);
                let quote_hex = hex::decode(processed).expect(error_msg);
                quote_hex
            }
        },
    }
}

pub fn remove_prefix_if_found(h: &str) -> &str {
    if h.starts_with("0x") { &h[2..] } else { &h }
}
