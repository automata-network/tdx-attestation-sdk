use clap::{Args, Parser, Subcommand, ValueEnum};
use std::fs::read_to_string;
use std::path::PathBuf;

const MANIFEST_DIR: &str = env!("CARGO_MANIFEST_DIR");
const DEFAULT_QUOTE_PATH: &str = "./data/quote.hex";

#[derive(Debug, Clone, Copy, PartialEq, Eq, ValueEnum)]
pub enum ProvingStrategy {
    #[value(name = "bonsai")]
    Bonsai,
    #[value(name = "boundless")]
    Boundless,
}

impl Default for ProvingStrategy {
    fn default() -> Self {
        ProvingStrategy::Bonsai
    }
}

#[derive(Parser)]
#[command(name = "DcapBonsaiApp")]
#[command(version = "1.1.0")]
#[command(about = "Gets Bonsai Proof for DCAP Quote Verification and submits on-chain")]
pub struct Cli {
    #[command(subcommand)]
    pub command: Commands,
}

#[derive(Subcommand)]
pub enum Commands {
    /// Fetches proof from Bonsai and sends them on-chain to verify DCAP quote
    Prove(DcapArgs),

    /// Computes the Image ID of the Guest application
    ImageId,

    /// De-serializes and prints information about the Output
    Deserialize(OutputArgs),
}

#[derive(Args)]
pub struct DcapArgs {
    /// The input quote provided as a hex string, this overwrites the --quote-path argument
    #[arg(short = 'q', long = "quote-hex")]
    pub quote_hex: Option<String>,

    /// Optional: The path to a quote.hex file. Default: /data/quote.hex or overwritten by the --quote-hex argument if provided.
    #[arg(short = 'p', long = "quote-path", env = "QUOTE_HEX_PATH")]
    pub quote_path: Option<PathBuf>,

    /// Optional: The Guest zkVM input generated by running input.rs executable
    #[arg(short = 'i', long = "input")]
    pub guest_input_path: Option<PathBuf>,

    /// Proving strategy to use (bonsai or boundless)
    #[arg(long = "proving-strategy", value_enum, default_value = "bonsai")]
    pub proving_strategy: ProvingStrategy,

    // Boundless-specific arguments
    /// RPC URL for Boundless (required if using boundless strategy)
    #[arg(long = "boundless-rpc-url", env = "BOUNDLESS_RPC_URL")]
    pub boundless_rpc_url: Option<String>,

    /// Wallet private key for Boundless (required if using boundless strategy)
    #[arg(long = "boundless-private-key", env = "ETH_WALLET_PRIVATE_KEY")]
    pub boundless_private_key: Option<String>,

    /// URL to the guest ELF program (optional, for Boundless)
    #[arg(long = "boundless-program-url")]
    pub boundless_program_url: Option<String>,

    /// Proof type for Boundless (groth16 or merkle)
    #[arg(long = "boundless-proof-type", value_enum, default_value = "groth16")]
    pub boundless_proof_type: crate::boundless::ProofType,

    /// Minimum price in wei (optional, for Boundless)
    #[arg(long = "boundless-min-price")]
    pub boundless_min_price: Option<u128>,

    /// Maximum price in wei (optional, for Boundless)
    #[arg(long = "boundless-max-price")]
    pub boundless_max_price: Option<u128>,

    /// Timeout in seconds (optional, for Boundless)
    #[arg(long = "boundless-timeout")]
    pub boundless_timeout: Option<u32>,

    /// Ramp up period in seconds (optional, for Boundless)
    #[arg(long = "boundless-ramp-up-period")]
    pub boundless_ramp_up_period: Option<u32>,
}

#[derive(Args)]
pub struct OutputArgs {
    #[arg(short = 'o', long = "output")]
    pub output: String,
}

pub fn get_quote(path: &Option<PathBuf>, hex: &Option<String>) -> Vec<u8> {
    let error_msg: &str = "Failed to read quote from the provided path";
    match hex {
        Some(h) => {
            let quote_hex = hex::decode(h).expect(error_msg);
            quote_hex
        }
        _ => match path {
            Some(p) => {
                let quote_string = read_to_string(p).expect(error_msg);
                let processed = remove_prefix_if_found(&quote_string);
                let quote_hex = hex::decode(processed).expect(error_msg);
                quote_hex
            }
            _ => {
                let default_path = PathBuf::from(format!(
                    "{}/{}",
                    MANIFEST_DIR,
                    DEFAULT_QUOTE_PATH
                ));
                let quote_string = read_to_string(default_path).expect(error_msg);
                let processed = remove_prefix_if_found(&quote_string);
                let quote_hex = hex::decode(processed).expect(error_msg);
                quote_hex
            }
        },
    }
}

pub fn remove_prefix_if_found(h: &str) -> &str {
    if h.starts_with("0x") {
        &h[2..]
    } else {
        &h
    }
}
