use clap::{Args, Parser, Subcommand};
use std::fs::read_to_string;
use std::path::PathBuf;

const MANIFEST_DIR: &str = env!("CARGO_MANIFEST_DIR");
const DEFAULT_QUOTE_PATH: &str = "./data/quote.hex";

#[derive(Parser)]
#[command(name = "DcapBonsaiApp")]
#[command(version = "1.1.0")]
#[command(about = "Gets Bonsai Proof for DCAP Quote Verification and submits on-chain")]
pub struct Cli {
    #[command(subcommand)]
    pub command: Commands,
}

#[derive(Subcommand)]
pub enum Commands {
    /// Fetches proof from Bonsai and sends them on-chain to verify DCAP quote
    Prove(DcapArgs),

    /// Computes the Image ID of the Guest application
    ImageId,

    /// De-serializes and prints information about the Output
    Deserialize(OutputArgs),
}

#[derive(Args)]
pub struct DcapArgs {
    /// The input quote provided as a hex string, this overwrites the --quote-path argument
    #[arg(short = 'q', long = "quote-hex")]
    pub quote_hex: Option<String>,

    /// Optional: The path to a quote.hex file. Default: /data/quote.hex or overwritten by the --quote-hex argument if provided.
    #[arg(short = 'p', long = "quote-path", env = "QUOTE_HEX_PATH")]
    pub quote_path: Option<PathBuf>,

    /// Optional: The Guest zkVM input generated by running input.rs executable
    #[arg(short = 'i', long = "input")]
    pub guest_input_path: Option<PathBuf>,
}

#[derive(Args)]
pub struct OutputArgs {
    #[arg(short = 'o', long = "output")]
    pub output: String,
}

pub fn get_quote(path: &Option<PathBuf>, hex: &Option<String>) -> Vec<u8> {
    let error_msg: &str = "Failed to read quote from the provided path";
    match hex {
        Some(h) => {
            let quote_hex = hex::decode(h).expect(error_msg);
            quote_hex
        }
        _ => match path {
            Some(p) => {
                let quote_string = read_to_string(p).expect(error_msg);
                let processed = remove_prefix_if_found(&quote_string);
                let quote_hex = hex::decode(processed).expect(error_msg);
                quote_hex
            }
            _ => {
                let default_path = PathBuf::from(format!(
                    "{}/{}",
                    MANIFEST_DIR,
                    DEFAULT_QUOTE_PATH
                ));
                let quote_string = read_to_string(default_path).expect(error_msg);
                let processed = remove_prefix_if_found(&quote_string);
                let quote_hex = hex::decode(processed).expect(error_msg);
                quote_hex
            }
        },
    }
}

pub fn remove_prefix_if_found(h: &str) -> &str {
    if h.starts_with("0x") {
        &h[2..]
    } else {
        &h
    }
}
