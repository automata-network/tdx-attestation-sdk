// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{DCAP_GUEST_ELF, DCAP_GUEST_ID};
use risc0_ethereum_contracts::groth16;
use risc0_zkvm::{
    compute_image_id, default_prover, ExecutorEnv, InnerReceipt, ProverOpts,
    VERSION as RISCZERO_VERSION,
};

use clap::Parser;
use core::GuestInput;
use dcap_bonsai_cli::cli::*;
use dcap_rs::types::collateral::Collateral;
use dcap_rs::types::VerifiedOutput;
use pccs_reader_rs::{
    dotenvy, find_missing_collaterals_from_quote, tcb_pem::generate_tcb_issuer_chain_pem,
};

#[tokio::main]
async fn main() {
    dotenvy::dotenv().ok();

    let cli = Cli::parse();

    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    match &cli.command {
        Commands::ImageId => {
            println!(
                "ImageID: {}",
                compute_image_id(DCAP_GUEST_ELF).unwrap().to_string()
            );
        }
        Commands::Deserialize(args) => {
            let output_vec =
                hex::decode(remove_prefix_if_found(&args.output)).expect("Failed to parse output");
            let deserialized_output = VerifiedOutput::from_bytes(&output_vec);
            println!("Deserialized output: {:?}", deserialized_output);
        }
        Commands::Prove(args) => {
            let raw_quote = get_quote(&args.quote_path, &args.quote_hex);

            let fetched_collaterals =
                find_missing_collaterals_from_quote(raw_quote.as_slice(), false)
                    .await
                    .unwrap();

            log::debug!("Fetched collaterals: {:?}", fetched_collaterals);

            let tcb_issuer_chain_pem = generate_tcb_issuer_chain_pem(
                fetched_collaterals.tcb_signing_ca.as_slice(),
                fetched_collaterals.root_ca.as_slice(),
            );

            let collateral = Collateral::new(
                fetched_collaterals.root_ca_crl.as_slice(),
                fetched_collaterals.pck_crl.as_slice(),
                tcb_issuer_chain_pem.unwrap().as_bytes(),
                fetched_collaterals.tcb_info.as_str(),
                fetched_collaterals.qe_identity.as_str(),
            )
            .unwrap();

            // get current time in seconds since epoch
            let current_time = std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_secs();

            let guest_input = GuestInput {
                raw_quote: raw_quote.to_vec(),
                collateral: collateral,
                timestamp: current_time,
            };

            let input_bytes = guest_input.sol_abi_encode();
            let env = ExecutorEnv::builder()
                .write_slice(&input_bytes)
                .build()
                .unwrap();

            log::debug!("Guest input: {}", hex::encode(&input_bytes));
            log::info!("RISC Zero version: {}", RISCZERO_VERSION);
            log::info!("Image ID: {}", compute_image_id(DCAP_GUEST_ELF).unwrap());

            // Obtain the default prover.
            let prover = default_prover();
            // Produce a receipt by proving the specified ELF binary.
            let prover_opts = if std::env::var("BONSAI_API_KEY").is_ok() {
                ProverOpts::groth16()
            } else {
                ProverOpts::default()
            };
            let receipt = prover
                .prove_with_opts(env, DCAP_GUEST_ELF, &prover_opts)
                .unwrap()
                .receipt;

            if let InnerReceipt::Groth16(ref groth16_receipt) = receipt.inner {
                println!(
                    "Groth16 Seal bytes: {}",
                    hex::encode(
                        groth16::encode(groth16_receipt.seal.clone())
                            .unwrap()
                            .as_slice()
                    )
                );
                println!(
                    "Output bytes: {}",
                    hex::encode(receipt.journal.bytes.clone().as_slice())
                )
            }

            // verify your receipt
            receipt.verify(DCAP_GUEST_ID).unwrap();

            let output = receipt.journal.bytes;

            // manually parse the output
            let mut offset: usize = 0;
            let output_len = u16::from_be_bytes(output[offset..offset + 2].try_into().unwrap());

            offset += 2;
            let verified_output =
                VerifiedOutput::from_bytes(&output[offset..offset + output_len as usize]).unwrap();
            offset += output_len as usize;
            let current_time = u64::from_be_bytes(output[offset..offset + 8].try_into().unwrap());
            offset += 8;
            let tcbinfo_root_hash = &output[offset..offset + 32];
            offset += 32;
            let enclaveidentity_root_hash = &output[offset..offset + 32];
            offset += 32;
            let root_cert_hash = &output[offset..offset + 32];
            offset += 32;
            let signing_cert_hash = &output[offset..offset + 32];
            offset += 32;
            let root_crl_hash = &output[offset..offset + 32];
            offset += 32;
            let pck_crl_hash = &output[offset..offset + 32];

            println!("Verified Output: {:?}", verified_output);
            println!("Current time: {}", current_time);
            println!("TCB Info Root Hash: {:?}", tcbinfo_root_hash);
            println!(
                "Enclave Identity Root Hash: {:?}",
                enclaveidentity_root_hash
            );
            println!("Root Cert Hash: {:?}", root_cert_hash);
            println!("Signing Cert Hash: {:?}", signing_cert_hash);
            println!("RootCRL Hash: {:?}", root_crl_hash);
            println!("PCK CRL Hash: {:?}", pck_crl_hash);
        }
    }
}
