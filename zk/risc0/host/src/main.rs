// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{DCAP_GUEST_ELF, DCAP_GUEST_ID};
use risc0_zkvm::{compute_image_id, default_prover, ExecutorEnv, InnerReceipt, ProverOpts};

use core::GuestInput;
use dcap_rs::types::collateral::Collateral;
use dcap_rs::types::VerifiedOutput;

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    println!(
        "ImageID: {}",
        compute_image_id(DCAP_GUEST_ELF).unwrap().to_string()
    );

    let raw_quote = include_bytes!("../data/quote.dat");

    let collateral = Collateral::new(
        include_bytes!("../data/intel_root_crl.der"),
        include_bytes!("../data/pck_platform_crl.der"),
        include_bytes!("../data/signing_cert.pem"),
        include_str!("../data/tcbinfo-tdx-v3.json"),
        include_str!("../data/identity_tdx.json"),
    )
    .unwrap();

    // // get current time in seconds since epoch
    // let current_time = std::time::SystemTime::now()
    //     .duration_since(std::time::UNIX_EPOCH)
    //     .unwrap()
    //     .as_secs();

    let current_time = 1749095100u64;

    let guest_input = GuestInput {
        raw_quote: raw_quote.to_vec(),
        collateral: collateral,
        timestamp: current_time,
    };

    let input_string = serde_json::to_string(&guest_input).unwrap();
    let env = ExecutorEnv::builder()
        .write(&input_string)
        .unwrap()
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();
    // Produce a receipt by proving the specified ELF binary.
    let prover_opts = if std::env::var("BONSAI_API_KEY").is_ok() {
        ProverOpts::groth16()
    } else {
        ProverOpts::default()
    };
    let receipt = prover
        .prove_with_opts(env, DCAP_GUEST_ELF, &prover_opts)
        .unwrap()
        .receipt;

    if let InnerReceipt::Groth16(ref groth16_receipt) = receipt.inner {
        println!(
            "Groth16 Seal bytes: {}",
            hex::encode(groth16_receipt.seal.as_slice())
        );
        println!(
            "Output bytes: {}",
            hex::encode(receipt.journal.bytes.clone().as_slice())
        )
    }

    // Optional: Verify receipt to confirm that recipients will also be able to
    // verify your receipt
    receipt.verify(DCAP_GUEST_ID).unwrap();

    let output = receipt.journal.bytes;

    // manually parse the output
    let mut offset: usize = 0;
    let output_len = u16::from_be_bytes(output[offset..offset + 2].try_into().unwrap());
    offset += 2;
    let verified_output =
        VerifiedOutput::from_bytes(&output[offset..offset + output_len as usize]).unwrap();
    offset += output_len as usize;
    let current_time = u64::from_be_bytes(output[offset..offset + 8].try_into().unwrap());
    offset += 8;
    let tcbinfo_root_hash = &output[offset..offset + 32];
    offset += 32;
    let enclaveidentity_root_hash = &output[offset..offset + 32];
    offset += 32;
    let root_cert_hash = &output[offset..offset + 32];
    offset += 32;
    let signing_cert_hash = &output[offset..offset + 32];
    offset += 32;
    let root_crl_hash = &output[offset..offset + 32];
    offset += 32;
    let pck_crl_hash = &output[offset..offset + 32];

    // println!("Hello, world! I generated a proof of guest execution! \n{:?}.", verified_output);
    println!("Verified Output: {:?}", verified_output);
    println!("Current time: {}", current_time);
    println!("TCB Info Root Hash: {:?}", tcbinfo_root_hash);
    println!(
        "Enclave Identity Root Hash: {:?}",
        enclaveidentity_root_hash
    );
    println!("Root Cert Hash: {:?}", root_cert_hash);
    println!("Signing Cert Hash: {:?}", signing_cert_hash);
    println!("RootCRL Hash: {:?}", root_crl_hash);
    println!("PCK CRL Hash: {:?}", pck_crl_hash);
}
