// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::DCAP_GUEST_ELF;
use risc0_zkvm::{compute_image_id, VERSION as RISCZERO_VERSION};

use clap::Parser;
use core::GuestInput;
use dcap_risc0_cli::cli::*;
use dcap_rs::types::collateral::Collateral;
use dcap_rs::types::VerifiedOutput;
use pccs_reader_rs::{
    dotenvy, find_missing_collaterals_from_quote, tcb_pem::generate_tcb_issuer_chain_pem,
};

#[tokio::main]
async fn main() {
    dotenvy::dotenv().ok();

    let cli = Cli::parse();

    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    match &cli.command {
        Commands::ImageId => {
            println!(
                "ImageID: {}",
                compute_image_id(DCAP_GUEST_ELF).unwrap().to_string()
            );
        }
        Commands::Deserialize(args) => {
            let output_vec =
                hex::decode(remove_prefix_if_found(&args.output)).expect("Failed to parse output");
            let deserialized_output = VerifiedOutput::from_bytes(&output_vec);
            println!("Deserialized output: {:?}", deserialized_output);
        }
        Commands::Prove(args) => {
            let input_bytes = if let Some(input_path) = &args.guest_input_path {
                std::fs::read(input_path).expect("Failed to read guest input file")
            } else {
                let raw_quote = get_quote(&args.quote_path, &args.quote_hex);
                let fetched_collaterals =
                    find_missing_collaterals_from_quote(raw_quote.as_slice(), false)
                        .await
                        .unwrap();
                log::debug!("Fetched collaterals: {:?}", fetched_collaterals);
                let tcb_issuer_chain_pem = generate_tcb_issuer_chain_pem(
                    fetched_collaterals.tcb_signing_ca.as_slice(),
                    fetched_collaterals.root_ca.as_slice(),
                );
                let collateral = Collateral::new(
                    fetched_collaterals.root_ca_crl.as_slice(),
                    fetched_collaterals.pck_crl.as_slice(),
                    tcb_issuer_chain_pem.unwrap().as_bytes(),
                    fetched_collaterals.tcb_info.as_str(),
                    fetched_collaterals.qe_identity.as_str(),
                )
                .unwrap();
                // get current time in seconds since epoch
                let current_time = std::time::SystemTime::now()
                    .duration_since(std::time::UNIX_EPOCH)
                    .unwrap()
                    .as_secs();
                let guest_input = GuestInput {
                    raw_quote: raw_quote.to_vec(),
                    collateral: collateral,
                    timestamp: current_time,
                };
                guest_input.sol_abi_encode()
            };

            log::debug!("Guest input: {}", hex::encode(&input_bytes));
            log::info!("RISC Zero version: {}", RISCZERO_VERSION);
            log::info!("Image ID: {}", compute_image_id(DCAP_GUEST_ELF).unwrap());

            match args.proving_strategy {
                dcap_risc0_cli::cli::ProvingStrategy::Bonsai => {
                    dcap_risc0_cli::proving::prove_with_bonsai(&input_bytes).await;
                }
                dcap_risc0_cli::cli::ProvingStrategy::Boundless => {
                    dcap_risc0_cli::proving::prove_with_boundless(&input_bytes, args).await;
                }
            }
        }
    }
}

